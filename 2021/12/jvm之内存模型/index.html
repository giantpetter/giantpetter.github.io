<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JVM之内存模型 - 拾光的博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="拾光" /><meta name="description" content="Java与C&#43;&#43;之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。 一、内存简介 1.1 内核空间与用户空间 一" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.83.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/2021/12/jvm%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="JVM之内存模型" />
<meta property="og:description" content="Java与C&#43;&#43;之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。 一、内存简介 1.1 内核空间与用户空间 一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2021/12/jvm%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-11T10:44:02&#43;08:00" />
<meta property="article:modified_time" content="2021-12-11T23:44:02&#43;08:00" />

<meta itemprop="name" content="JVM之内存模型">
<meta itemprop="description" content="Java与C&#43;&#43;之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。 一、内存简介 1.1 内核空间与用户空间 一"><meta itemprop="datePublished" content="2021-12-11T10:44:02&#43;08:00" />
<meta itemprop="dateModified" content="2021-12-11T23:44:02&#43;08:00" />
<meta itemprop="wordCount" content="5843">
<meta itemprop="keywords" content="JVM," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JVM之内存模型"/>
<meta name="twitter:description" content="Java与C&#43;&#43;之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。 一、内存简介 1.1 内核空间与用户空间 一"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">拾光</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">拾光</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JVM之内存模型</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-11 </span>
        <div class="post-category">
            <a href="/categories/java/"> Java </a>
            </div>
          <span class="more-meta"> 5843 words </span>
          <span class="more-meta"> 12 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一内存简介">一、内存简介</a>
      <ul>
        <li><a href="#11-内核空间与用户空间">1.1 内核空间与用户空间</a></li>
        <li><a href="#12-使用内存的-java-组件">1.2 使用内存的 Java 组件</a></li>
      </ul>
    </li>
    <li><a href="#二运行时数据区域">二、运行时数据区域</a>
      <ul>
        <li><a href="#21-程序计数器">2.1 程序计数器</a></li>
        <li><a href="#22-java-虚拟机栈">2.2 Java 虚拟机栈</a></li>
        <li><a href="#23-java-本地方法栈">2.3 Java 本地方法栈</a></li>
        <li><a href="#24-java-堆">2.4 Java 堆</a></li>
        <li><a href="#25-java-方法区">2.5 Java 方法区</a></li>
        <li><a href="#26-java-运行时常量池">2.6 Java 运行时常量池</a></li>
        <li><a href="#27-java-直接内存">2.7 Java 直接内存</a></li>
        <li><a href="#28-java-内存区域对比">2.8 Java 内存区域对比</a></li>
      </ul>
    </li>
    <li><a href="#三jvm-运行原理">三、JVM 运行原理</a></li>
    <li><a href="#四outofmemoryerror">四、OutOfMemoryError</a>
      <ul>
        <li><a href="#41-什么是-outofmemoryerror">4.1 什么是 <code>OutOfMemoryError</code></a></li>
        <li><a href="#42-java-堆空间溢出">4.2 Java 堆空间溢出</a>
          <ul>
            <li><a href="#421-内存泄漏">4.2.1 内存泄漏</a></li>
            <li><a href="#422-内存溢出">4.2.2 内存溢出</a></li>
          </ul>
        </li>
        <li><a href="#43-gc-开销超过限制">4.3 GC 开销超过限制</a></li>
        <li><a href="#44-永久代空间不足">4.4 永久代空间不足</a></li>
        <li><a href="#45-元数据区空间不足">4.5 元数据区空间不足</a></li>
        <li><a href="#46-无法建立本地线程">4.6 无法建立本地线程</a></li>
        <li><a href="#47-直接内存溢出">4.7 直接内存溢出</a></li>
      </ul>
    </li>
    <li><a href="#五stackoverflowerror">五、StackOverflowError</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><strong><code>Java</code>与<code>C++</code>之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</strong></p>
<h1 id="一内存简介">一、内存简介</h1>
<h2 id="11-内核空间与用户空间">1.1 内核空间与用户空间</h2>
<p>一台计算机通常有固定大小的内存空间，但是程序并不能使用全部的空间。因为这些空间被分为操作系统内核空间和用户空间，而程序只能使用用户空间的内存。</p>
<h2 id="12-使用内存的-java-组件">1.2 使用内存的 Java 组件</h2>
<p>Java 启动后，作为一个进程运行在操作系统中，那些组件会需要占用内存？</p>
<ul>
<li>堆内存：Java 堆、类和类加载器</li>
<li>栈内存：线程</li>
<li>本地内存：NIO、JNI</li>
</ul>
<h1 id="二运行时数据区域">二、运行时数据区域</h1>
<p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域 有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是 依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="/images/JVM/memo/runtime.png" alt=""></p>
<h2 id="21-程序计数器">2.1 程序计数器</h2>
<p><code>程序计数器（Program Counter Register）</code>是一块较小的内存空间，它可以看作是<strong>当前线程</strong>所执行的字节码的行号指示器。例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一
个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因
此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程
之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址;</li>
<li>如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
</ul>
<h2 id="22-java-虚拟机栈">2.2 Java 虚拟机栈</h2>
<p><code>Java 虚拟机栈（Java Virtual Machine Stacks）</code> 也是线程私有的，它的生命周期<strong>与线程相同。</strong></p>
<p>每个 Java 方法在执行的同时都会创建一个<code>栈帧（Stack Frame）</code>用于存储 <strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>常量池引用</strong> 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<ul>
<li><strong>局部变量表</strong>: 在内存空间以局部变量槽(slot, 32位)来表示，存放了编译期可知的各种基本数据类型、对象引用、ReturnAddress 类型，并且空间在编译器已经分配。在方法运行期间不会改变局部变量表的大小</li>
<li><strong>操作数栈</strong>: 基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。</li>
<li><strong>动态链接</strong>: 每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接引用，这部分称为动态链接。</li>
<li><strong>方法出口</strong>: 返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果没有返回值，则把它压入调用者的操作数栈。</li>
</ul>
<blockquote>
<p>注意!该区域可能抛出以下异常：</p>
<ul>
<li>如果线程请求的栈深度超过最大值，就会抛出 <code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机栈进行动态扩展时，无法申请到足够内存，就会抛出 <code>OutOfMemoryError</code> 异常。<br></li>
</ul>
<p>提示:<br>
可以通过 <code>-Xss</code> 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="n">java</span> <span class="o">-</span><span class="n">Xss</span><span class="o">=</span><span class="n">512M</span> <span class="n">HackTheJava</span>
</code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="23-java-本地方法栈">2.3 Java 本地方法栈</h2>
<p><code>本地方法栈（Native Method Stacks）</code>与虚拟机栈所发挥的作用是非常相似的。</p>
<p>区别在于: <strong>虚拟机栈为 Java 方法服务;本地方法栈为 Native 方法服务。</strong> 本地方法是由 C 语言实现的。<br></p>
<blockquote>
<p>注意：
本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>
</blockquote>
<h2 id="24-java-堆">2.4 Java 堆</h2>
<p>对于Java应用程序来说，<code>Java堆（Java Heap）</code>是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。。此内存区域的唯一目的就是<strong>存放对象实例</strong>，Java 世界里“几乎”所有的对象实例都在这里分配内存。</p>
<p>Java 堆是垃圾收集器管理的内存区域(所以也被称为 &lsquo;GC&rsquo; 堆)。由于现代垃圾收集器大部分都是基于<code>分代收集理论</code>设计的，该算法的思想是针对不同的对象采取不同的垃圾回收算法。</p>
<p>因此虚拟机把 Java 堆分成以下三块：</p>
<ul>
<li>新生代 Young Generation
<ul>
<li>Eden -Eden 和 Survivor 的比例为 8:1</li>
<li>From Survival</li>
<li>To Survival</li>
</ul>
</li>
<li>老年代 Old Generation</li>
<li>永久代 Permanent Generation</li>
</ul>
<p>当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。具体的垃圾回收机制会在下一个篇章中介绍。</p>
<blockquote>
<p>注意：Java 堆不需要连续内存，并且可以动态扩展其内存，扩展失败会抛出 <code>OutOfMemoryError</code> 异常。<br>
可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="n">java</span> <span class="o">-</span><span class="n">Xms</span><span class="o">=</span><span class="n">1M</span> <span class="o">-</span><span class="n">Xmx</span><span class="o">=</span><span class="n">2M</span> <span class="n">HackTheJava</span>
</code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="25-java-方法区">2.5 Java 方法区</h2>
<p><code>方法区（Method Area</code>也被称为永久代(Hotspot 虚拟机)，由各个线程共享。方法区用于存放<strong>已被加载的类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译(JIT)后的代码</strong>等数据。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<blockquote>
<p><strong>注意：</strong><br>
和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 <code>OutOfMemoryError</code> 异常。<br>
<br></p>
<p><strong>提示：</strong></p>
<ul>
<li>JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收。可通过参数 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置。</li>
<li>JDK 1.8 之后，取消了永久代，用 <strong>metaspace(元数据)</strong> 区替代。可通过参数 <code>-XX:MaxMetaspaceSize</code> 设置。</li>
</ul>
</blockquote>
<h2 id="26-java-运行时常量池">2.6 Java 运行时常量池</h2>
<p><code>运行时常量池（Runtime Constant Pool）</code>是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的<strong>各种字面量和符号引用</strong>，这部分内容会在<em>类加载后</em>被放入这个区域。</p>
<ul>
<li><strong>字面量</strong> - 文本字符串、声明为 final 的常量值等。</li>
<li><strong>符号引用</strong> - 类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。</li>
</ul>
<p>除了在编译期生成的常量，还允许动态生成，例如 <code>String</code> 类的 <code>intern()</code>。这部分常量也会被放入运行时常量池。</p>
<blockquote>
<p>注意：<br>
既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存
时会抛出 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h2 id="27-java-直接内存">2.7 Java 直接内存</h2>
<p><code>直接内存（Direct Memory）</code>并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现</p>
<p>在JDK 1.4中新加入了<code>NIO（New Input/Output）</code>类，引入了一种基于<strong>通道(Channel)<strong>与</strong>缓冲区(Buffer)</strong> 的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的<code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<h2 id="28-java-内存区域对比">2.8 Java 内存区域对比</h2>
<table>
<thead>
<tr>
<th><strong>内存区域</strong></th>
<th><strong>内存作用范围</strong></th>
<th><strong>异常</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>程序计数器</td>
<td><em>线程私有</em></td>
<td>无</td>
</tr>
<tr>
<td>Java 虚拟机栈</td>
<td><em>线程私有</em></td>
<td><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>本地方法栈</td>
<td><em>线程私有</em></td>
<td><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>Java 堆</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>方法区</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>运行时常量池</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>直接内存</td>
<td>非运行时数据区</td>
<td><code>OutOfMemoryError</code></td>
</tr>
</tbody>
</table>
<h1 id="三jvm-运行原理">三、JVM 运行原理</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JVMCase</span> <span class="o">{</span>

	<span class="c1">// 常量
</span><span class="c1"></span>	<span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">MAN_SEX_TYPE</span> <span class="o">=</span> <span class="s">&#34;man&#34;</span><span class="o">;</span>

	<span class="c1">// 静态变量
</span><span class="c1"></span>	<span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">WOMAN_SEX_TYPE</span> <span class="o">=</span> <span class="s">&#34;woman&#34;</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

		<span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">();</span>
		<span class="n">stu</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;nick&#34;</span><span class="o">);</span>
		<span class="n">stu</span><span class="o">.</span><span class="na">setSexType</span><span class="o">(</span><span class="n">MAN_SEX_TYPE</span><span class="o">);</span>
		<span class="n">stu</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="n">20</span><span class="o">);</span>

		<span class="n">JVMCase</span> <span class="n">jvmcase</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JVMCase</span><span class="o">();</span>

		<span class="c1">// 调用静态方法
</span><span class="c1"></span>		<span class="n">print</span><span class="o">(</span><span class="n">stu</span><span class="o">);</span>
		<span class="c1">// 调用非静态方法
</span><span class="c1"></span>		<span class="n">jvmcase</span><span class="o">.</span><span class="na">sayHello</span><span class="o">(</span><span class="n">stu</span><span class="o">);</span>
	<span class="o">}</span>


	<span class="c1">// 常规静态方法
</span><span class="c1"></span>	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">Student</span> <span class="n">stu</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;name: &#34;</span> <span class="o">+</span> <span class="n">stu</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;; sex:&#34;</span> <span class="o">+</span> <span class="n">stu</span><span class="o">.</span><span class="na">getSexType</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;; age:&#34;</span> <span class="o">+</span> <span class="n">stu</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>
	<span class="o">}</span>


	<span class="c1">// 非静态方法
</span><span class="c1"></span>	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">Student</span> <span class="n">stu</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stu</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;say: hello&#34;</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Student</span><span class="o">{</span>
	<span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="n">String</span> <span class="n">sexType</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

	<span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="n">String</span> <span class="nf">getSexType</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">sexType</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSexType</span><span class="o">(</span><span class="n">String</span> <span class="n">sexType</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">sexType</span> <span class="o">=</span> <span class="n">sexType</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">age</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行以上代码时，JVM 处理过程如下：</p>
<ol>
<li>JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。</li>
<li>JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</li>
<li><code>class</code> 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值。
<img src="/images/JVM/memo/classload.png" alt=""></li>
<li>完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 <code>&lt;clinit&gt;</code> 方法，编译器会在 <code>.java</code> 文件被编译成 .<code>class</code> 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <code>&lt;clinit&gt;()</code> 方法。
<img src="/images/JVM/memo/classload2.png" alt=""></li>
<li>执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中。
<img src="/images/JVM/memo/classload3.png" alt=""></li>
<li>此时再次创建一个 JVMCase 对象，调用 sayHello 非静态方法，sayHello 方法属于对象 JVMCase，此时 sayHello 方法入栈，并通过栈中的 student 引用调用堆中的 Student 对象；之后，调用静态方法 print，print 静态方法属于 JVMCase 类，是从静态方法中获取，之后放入到栈中，也是通过 student 引用调用堆中的 student 对象。
<img src="/images/JVM/memo/classload4.png" alt=""></li>
</ol>
<h1 id="四outofmemoryerror">四、OutOfMemoryError</h1>
<h2 id="41-什么是-outofmemoryerror">4.1 什么是 <code>OutOfMemoryError</code></h2>
<p><code>OutOfMemoryError</code> 简称为 OOM。Java 中对 OOM 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。通俗的解释是：JVM 内存不足了。</p>
<p>在 JVM 规范中，除了<em>程序计数器区域</em>外，其他运行时区域都可能发生 <code>OutOfMemoryError</code> 异常</p>
<p>下面逐一介绍 OOM 发生场景。</p>
<h2 id="42-java-堆空间溢出">4.2 Java 堆空间溢出</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">Java</span> <span class="n">heap</span> <span class="n">space</span>
</code></pre></td></tr></table>
</div>
</div><p>该错误意味着：<strong>对空间溢出</strong></p>
<p>Java 堆内存已经达到 -Xmx 设置的最大值。Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾收集器回收这些对象，那么当堆空间到达最大容量限制后就会产生 OOM。</p>
<p>堆空间溢出有可能是 <strong>内存泄漏（Memory Leak）</strong> 或 <strong>内存溢出（Memory Overflow）</strong> 。需要使用 <code>jstack</code> 和 <code>jmap</code> 生成 <code>threaddump</code> 和 <code>heapdump</code>，然后用内存分析工具（如：MAT）进行分析。</p>
<h3 id="421-内存泄漏">4.2.1 内存泄漏</h3>
<p><em>内存泄漏</em>是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况</p>
<p>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏随着被执行的次数不断增加，最终会导致内存溢出。包括以下场景：</p>
<ul>
<li>静态容器 -声明静态的 <code>HashMap</code>、<code>ArrayList</code>等集合；通俗来讲 A 中有 B，当前只把 B 设置为空，A 没有设置为空，回收时 B 无法回收。因为被 A 引用。</li>
<li>监听器 -监听器被注册后释放对象时没有删除监听器</li>
<li>物理连接 -各种连接池建立连接，必须通过<code>close()</code>关闭连接</li>
<li>内部类和外部模块等的引用</li>
</ul>
<h3 id="422-内存溢出">4.2.2 内存溢出</h3>
<p>如果不存在内存泄漏，即内存中的对象确实都必须存活着，则应当检查虚拟机的堆参数(<code>-Xmx</code> 和 <code>-Xms</code>）,与机器物理内存进行对比，看看是否可以调大.并从代码上检查是否存在某些对象生命周期过长、持有时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h2 id="43-gc-开销超过限制">4.3 GC 开销超过限制</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">GC</span> <span class="n">overhead</span> <span class="n">limit</span> <span class="n">exceeded</span>
</code></pre></td></tr></table>
</div>
</div><p>即：**超过 98% 的时间用来做 GC 并且回收了不到 2% 的堆内存时会抛出此异常。**这意味着，发生在 GC 占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。
[示例]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * GC overhead limit exceeded 示例
</span><span class="cm"> * 错误现象：java.lang.OutOfMemoryError: GC overhead limit exceeded
</span><span class="cm"> * 发生在GC占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。
</span><span class="cm"> * 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。
</span><span class="cm"> * VM Args: -Xms10M -Xmx10M
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GcOverheadLimitExceededDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">d</span><span class="o">++);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>[处理]
与 <code>Java heap space</code> 错误处理方法类似，先判断是否存在内存泄漏。如果有，则修正代码；如果没有，则通过 -Xms 和 -Xmx 适当调整堆内存大小。</p>
<h2 id="44-永久代空间不足">4.4 永久代空间不足</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">PermGen</span> <span class="n">space</span>
</code></pre></td></tr></table>
</div>
</div><p><code>Perm （永久代）</code>空间(Java 方法区，Hotspot)主要用于存放 Class 和 Meta 信息，包括类的名称和字段，带有方法字节码的方法，常量池信息，与类关联的对象数组和类型数组以及即时编译器优化。GC 在主程序运行期间不会对永久代空间进行清理，默认是 64M 大小。</p>
<p>根据上面的定义，可以得出 PermGen 大小要求取决于加载的类的数量以及此类声明的大小。因此，可以说造成该错误的主要原因是永久代中装入了太多的类或太大的类。</p>
<p>在 JDK8 之前的版本中，可以通过 -XX:PermSize 和 -XX:MaxPermSize 设置永久代空间大小，从而限制方法区大小，并间接限制其中常量池的容量。</p>
<h2 id="45-元数据区空间不足">4.5 元数据区空间不足</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">Metaspace</span>
</code></pre></td></tr></table>
</div>
</div><p>Java8 以后，JVM 内存空间发生了很大的变化。取消了永久代，转而变为元数据区。元数据区的内存不足，即 <strong>方法区和运行时常量池</strong> 的空间不足。</p>
<p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<p>当由于元空间而面临 OutOfMemoryError 时，第一个解决方案应该是显而易见的。如果应用程序耗尽了内存中的 Metaspace 区域，则应增加 Metaspace 的大小。更改应用程序启动配置并增加以下内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="o">-</span><span class="n">XX</span><span class="o">:</span><span class="n">MaxMetaspaceSize</span><span class="o">=</span><span class="n">512m</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="46-无法建立本地线程">4.6 无法建立本地线程</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">OutOfMemoryError</span><span class="o">:</span> <span class="n">Unable</span> <span class="n">to</span> <span class="n">create</span> <span class="k">new</span> <span class="kd">native</span> <span class="n">thread</span>
</code></pre></td></tr></table>
</div>
</div><p>这个错误意味着：Java 应用程序已达到其可以启动线程数的限制。</p>
<p>当发起一个线程的创建时，虚拟机会在 JVM 内存创建一个 Thread 对象同时创建一个操作系统线程，而这个系统线程的内存用的不是 JVM 内存，而是系统中剩下的内存。那么，究竟能创建多少线程呢？这里有一个公式：</p>
<blockquote>
<p>线程数 = (MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize)</p>
<ul>
<li><code>MaxProcessMemory</code> - 一个进程的最大内存</li>
<li><code>JVMMemory</code> - JVM 内存</li>
<li><code>ThreadStackSize</code> - 线程栈的大小</li>
</ul>
</blockquote>
<p>给 JVM 分配的内存越多，那么能用来创建系统线程的内存就会越少，越容易发生 <code>unable to create new native thread</code>。所以，JVM 内存不是分配的越大越好。</p>
<p>通常无法创建新的本机线程需要经历以下阶段：</p>
<ol>
<li>JVM 内部运行的应用程序请求新的 Java 线程</li>
<li>JVM 本机代码代理为操作系统创建新本机线程的请求</li>
<li>操作系统尝试创建一个新的本机线程，该线程需要将内存分配给该线程</li>
<li>操作系统将拒绝本机内存分配，原因是 32 位 Java 进程大小已耗尽其内存地址空间（例如，已达到（2-4）GB 进程大小限制）或操作系统的虚拟内存已完全耗尽</li>
<li>引发 <code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 错误。</li>
</ol>
<h2 id="47-直接内存溢出">4.7 直接内存溢出</h2>
<p>由直接内存导致的内存溢出，一个明显的特征是在 Head Dump 文件中不会看见明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，就可以考虑检查一下是不是这方面的原因。
[示例]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 本机直接内存溢出示例
</span><span class="cm"> * 错误现象：java.lang.OutOfMemoryError
</span><span class="cm"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirectOutOfMemoryDemo</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">_1MB</span> <span class="o">=</span> <span class="n">1024</span> <span class="o">*</span> <span class="n">1024</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IllegalAccessException</span> <span class="o">{</span>
        <span class="n">Field</span> <span class="n">unsafeField</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredFields</span><span class="o">()[</span><span class="n">0</span><span class="o">];</span>
        <span class="n">unsafeField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">Unsafe</span> <span class="n">unsafe</span> <span class="o">=</span> <span class="o">(</span><span class="n">Unsafe</span><span class="o">)</span> <span class="n">unsafeField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">unsafe</span><span class="o">.</span><span class="na">allocateMemory</span><span class="o">(</span><span class="n">_1MB</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="五stackoverflowerror">五、StackOverflowError</h1>
<p>对于 HotSpot 虚拟机来说，栈容量只由 <code>-Xss</code>参数来决定如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <code>StackOverflowError</code> 异常。</p>
<p>栈溢出的常见原因：</p>
<ul>
<li><strong>递归函数调用层数太深</strong></li>
<li><strong>大量循环或死循环</strong></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">拾光</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2021-12-11
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/jvm/">JVM</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2021/12/jvm%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JVM之类加载机制</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/2021/12/jvm%E4%B9%8B%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">
            <span class="next-text nav-default">JVM之体系结构</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="yang_95@126.com" class="iconfont icon-email" title="email"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>Huan</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>



<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
