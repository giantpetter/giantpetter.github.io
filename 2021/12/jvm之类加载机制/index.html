<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JVM之类加载机制 - 拾光的博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="拾光" /><meta name="description" content="一、概述 虚拟机的类加载:指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.83.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/2021/12/jvm%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="JVM之类加载机制" />
<meta property="og:description" content="一、概述 虚拟机的类加载:指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2021/12/jvm%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-24T21:19:28&#43;08:00" />
<meta property="article:modified_time" content="2021-12-24T21:19:28&#43;08:00" />

<meta itemprop="name" content="JVM之类加载机制">
<meta itemprop="description" content="一、概述 虚拟机的类加载:指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在"><meta itemprop="datePublished" content="2021-12-24T21:19:28&#43;08:00" />
<meta itemprop="dateModified" content="2021-12-24T21:19:28&#43;08:00" />
<meta itemprop="wordCount" content="7902">
<meta itemprop="keywords" content="JVM," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JVM之类加载机制"/>
<meta name="twitter:description" content="一、概述 虚拟机的类加载:指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">拾光</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">拾光</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JVM之类加载机制</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-24 </span>
        <div class="post-category">
            <a href="/categories/java/"> Java </a>
            </div>
          <span class="more-meta"> 7902 words </span>
          <span class="more-meta"> 16 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一概述">一、概述</a></li>
    <li><a href="#二类的生命周期">二、类的生命周期</a>
      <ul>
        <li><a href="#21-一-加载">2.1 (一) 加载</a></li>
        <li><a href="#22-二-验证">2.2 (二) 验证</a></li>
        <li><a href="#23-三-准备">2.3 (三) 准备</a></li>
        <li><a href="#24-四-解析">2.4 (四) 解析</a></li>
        <li><a href="#25-五-初始化">2.5 (五) 初始化</a>
          <ul>
            <li><a href="#类初始化细节"><strong>类初始化细节</strong></a></li>
            <li><a href="#类初始化方式"><strong>类初始化方式</strong></a></li>
            <li><a href="#类初始化步骤"><strong>类初始化步骤</strong></a></li>
            <li><a href="#类初始化时机"><strong>类初始化时机</strong></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#三classloader">三、ClassLoader</a>
      <ul>
        <li><a href="#31-类与类加载器">3.1 类与类加载器</a></li>
        <li><a href="#32-类加载器分类">3.2 类加载器分类</a>
          <ul>
            <li><a href="#1-bootstrap-classloader"><strong>(1) BootStrap ClassLoader</strong></a></li>
            <li><a href="#2-extclassloader"><strong>(2) ExtClassLoader</strong></a></li>
            <li><a href="#3-appclassloader"><strong>(3) AppClassLoader</strong></a></li>
            <li><a href="#4-自定义类加载器"><strong>(4) 自定义类加载器</strong></a></li>
          </ul>
        </li>
        <li><a href="#33-双亲委派">3.3 双亲委派</a>
          <ul>
            <li><a href="#1-工作过程"><strong>(1) 工作过程</strong></a></li>
            <li><a href="#2-优势"><strong>(2) 优势</strong></a></li>
            <li><a href="#3-实现"><strong>(3) 实现</strong></a></li>
          </ul>
        </li>
        <li><a href="#34-classloader-参数">3.4 ClassLoader 参数</a></li>
      </ul>
    </li>
    <li><a href="#四类的加载">四、类的加载</a>
      <ul>
        <li><a href="#41-类加载方式">4.1 类加载方式</a></li>
        <li><a href="#42-加载类错误">4.2 加载类错误</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="一概述">一、概述</h1>
<p><code>虚拟机的类加载:</code>指的是将类的 <code>.class</code> 文件中的二进制数据读入到内存中，将其放在运行时数据区的<strong>方法区</strong>内，然后在堆区创建一个 <code>java.lang.Class</code> 对象，用来封装类在方法区内的数据结构。类的加载的最终结果是位于 JVM 堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。</p>
<p><code>虚拟机的类加载机制:</code>Java虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型这一过程。</p>
<p>与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性， Java 天生可以动态扩展的语言特性就是依赖<strong>运行期动态加载和动态连接</strong>这个特点实现的。
<img src="/images/JVM/classLoad/lifeCycle.jpg" alt=""></p>
<h1 id="二类的生命周期">二、类的生命周期</h1>
<p><img src="/images/JVM/classLoad/lifeCycle2.png" alt="">
Java 类的完整生命周期包括以下 7 个阶段：</p>
<ul>
<li><strong>加载(Loading)</strong></li>
<li><strong>链接(Linking)</strong>
<ul>
<li><strong>验证(Verification)</strong></li>
<li><strong>准备(Preparation)</strong></li>
<li><strong>解析(Resolution)</strong></li>
</ul>
</li>
<li><strong>初始化(Initialization)</strong></li>
<li><strong>使用(Using)</strong></li>
<li><strong>卸载(Unloading)</strong></li>
</ul>
<p>如上图，类的加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这个顺序按部就班地开始。
而解析阶段则不一定：<strong>它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性</strong></p>
<p>类加载过程是指加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h2 id="21-一-加载">2.1 (一) 加载</h2>
<p>加载(Loading)是类加载(Class Loading)的一个阶段，注意不要混淆。</p>
<p><strong>加载(Loading):查找类字节流，并根据此创建类的过程。共完成三件事：</strong></p>
<ul>
<li>通过一个类的全限定名在获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的的静态存储结构转化为<em>方法区</em>的运行时存储结构。<strong>(静态存储 &mdash;&gt; 方法区)</strong></li>
<li>在内存(一般在堆中)中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。<strong>(在堆中生成类的 Class 对象)</strong></li>
</ul>
<p>《Java虚拟机规范》规定的这三点要求并不是很具体，故留给虚拟机具体实现与 Java 应用的灵活度都是相当大的。如第一条：并未规定获取此定义此类的二进制字节流从哪里、如何获取，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的 <code>findClass()</code> 或 <code>loadClass()</code> 方法）。</p>
<p>所以二进制字节流可以从以下方式获取：</p>
<ul>
<li>从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用是 Applet。</li>
<li>运行时计算生成，这种场景使用得最多得就是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 中，就是用了 <code>ProxyGenerator.generateProxyClass</code> 的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
<li>&hellip;</li>
</ul>
<h2 id="22-二-验证">2.2 (二) 验证</h2>
<p>验证是链接阶段的第一步。目的是<strong>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求</strong>,保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>从整体上看，验证阶段大致上会完成下面四个阶段的检验动作:</p>
<ul>
<li><strong>文件格式验证</strong>&ndash;&gt; 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。(<strong>注意</strong>：这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入 Java 虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。)</li>
<li><strong>元数据验证</strong>&mdash;-&gt; 对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。(父类，继承，抽象类等语义)</li>
<li><strong>字节码验证</strong>&mdash;-&gt; 该阶段是整个验证过程中最复杂的一个阶段,通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。(类的方法体)</li>
<li><strong>符号引用验证</strong>&ndash;&gt; 发生在虚拟机将符号引用转化为直接引用的时候，符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验。(private、static、public、&lt;package&gt;)</li>
</ul>
<h2 id="23-三-准备">2.3 (三) 准备</h2>
<p><strong>类变量是被 static 修饰的变量，准备阶段为 static 变量在方法区分配内存并初始化为默认值，使用的是方法区的内存。JDK 8以后，类变量则会随着Class对象一起存放在Java堆中</strong></p>
<p>实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次）</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被在准备阶段后的初始值为 0 而不是 123，在程序被编译过后执行构造器器<code>&lt;clinit&gt;()</code>方法之中才会赋值为 123：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">123</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>但是如果类变量是常量(Constant Value)，那么会按照表达式来初始化，而不是赋值为 0:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">123</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 Con-stantValue 的设置将 value 赋值为 123。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值；而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即 null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ol>
</blockquote>
<h2 id="24-四-解析">2.4 (四) 解析</h2>
<p><strong>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。</strong></p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行，分别对应于常量池的<code>CONSTANT_Class_info</code>、<code>CON-STANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>、<code>ONSTANT_InterfaceMethodref_info</code>、<code>CONSTANT_MethodType_info</code>、<code>CONSTANT_MethodHandle_info</code>、<code>CONSTANT_Dyna-mic_info</code> 和 <code>CONSTANT_InvokeDynamic_info</code> 8种常量类型。</p>
<ul>
<li><strong>符号引用(Symbolic References)</strong> &mdash;&gt; 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li><strong>直接引用(Direct Reference)</strong> &mdash;&mdash;&mdash;&gt; 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
</ul>
<blockquote>
<p>注意：</br>
在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。</br>
</br>
举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。</p>
</blockquote>
<h2 id="25-五-初始化">2.5 (五) 初始化</h2>
<p>在 Java 代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。</p>
<p>如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 <code>&lt; clinit &gt;</code></p>
<p><strong>类的初始化阶段</strong>是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。总之，<strong>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</strong></p>
<h3 id="类初始化细节"><strong>类初始化细节</strong></h3>
<p>类初始化 <code>&lt;clinit&gt;()</code> 方法的细节：
进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的<strong>赋值动作</strong>和**静态语句块(static{}块)**中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>                  <span class="c1">//  给变量赋值可以正常变异通过
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>    <span class="c1">// 这句话编译器会提示”非法向前引用“（无法访问）
</span><span class="c1"></span>    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>与类的构造函数（或者说实例构造器 <code>&lt;init&gt;()</code>）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 <code>&lt;clinit&gt;()</code> 方法运行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行结束。因此虚拟机中第一个执行 <code>&lt;clinit&gt;()</code> 方法的类肯定为 <code>java.lang.Object</code>。</li>
<li>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">A</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Sub</span> <span class="kd">extends</span> <span class="n">Parent</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Sub</span><span class="o">.</span><span class="na">B</span><span class="o">);</span> <span class="c1">// 输出的结果为父类的静态变量 A 的值，也就是 2.
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</li>
<li>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</li>
<li>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其它线程都会阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</li>
</ul>
<h3 id="类初始化方式"><strong>类初始化方式</strong></h3>
<ul>
<li>声明类变量时指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<h3 id="类初始化步骤"><strong>类初始化步骤</strong></h3>
<ol>
<li>如果类还没有被加载和链接，开始加载该类。</li>
<li>如果该类的直接父类还没有被初始化，先初始化其父类。</li>
<li>如果该类有初始化语句，则依次执行这些初始化语句。</li>
</ol>
<h3 id="类初始化时机"><strong>类初始化时机</strong></h3>
<p>只有<strong>主动引用类</strong>的时候才会导致类的初始化。</p>
<p>(1) 主动引用</p>
<p>类的主动引用包括以下六种：</p>
<ul>
<li><strong>创建类的实例</strong> &mdash;-&gt; <code>new</code> 一个对象</li>
<li><strong>访问静态变量</strong> &mdash;-&gt; 访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li><strong>访问静态方法</strong> &mdash;-&gt;</li>
<li><strong>反射</strong> &mdash;&mdash;&mdash;&ndash;&gt; 如<code>Class.forName(“com.shengsiyuan.Test”)</code></li>
<li><strong>初始化子类</strong> &mdash;&mdash;&gt; 初始化某个类的子类，则其父类也会被初始化</li>
<li><strong>启动类</strong>  &mdash;&mdash;&ndash;&gt; Java 虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li>
</ul>
<p>(2) 被动引用</p>
<p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li><strong>通过子类引用父类的静态字段，不会导致子类初始化。</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">SubClass</span><span class="o">.</span><span class="na">value</span><span class="o">);</span> <span class="c1">//value 字段在 SuperClass 中定义
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>通过数组定义来引用类，不会触发此类的初始化。</strong> 该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 <code>Object</code> 的子类，其中包含了数组的属性和方法(<code>length</code>, <code>clone()</code>)。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">SuperClass</span><span class="o">[]</span> <span class="n">sca</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SuperClass</span><span class="o">[</span><span class="n">10</span><span class="o">];</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>常量(final)在编译阶段会存入调用类的常量池中</strong>，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ConstClass</span><span class="o">.</span><span class="na">HELLOWORLD</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="三classloader">三、ClassLoader</h1>
<p><code>ClassLoader</code> 即类加载器，负责将类加载到 JVM。在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。</p>
<p>JVM 加载 class 文件到内存有两种方式：</p>
<ul>
<li>隐式加载 - JVM 自动加载需要的类到内存中。</li>
<li>显示加载 - 通过使用 ClassLoader 来加载一个类到内存中。</li>
</ul>
<h2 id="31-类与类加载器">3.1 类与类加载器</h2>
<p>如何判断两个类是否相等：类本身相等，并且使用同一个类加载器进行加载。这是因为<strong>每一个 ClassLoader 都拥有一个独立的类名称空间。</strong></p>
<p>这里的相等，包括类的 Class 对象的 <code>equals()</code> 方法、<code>isAssignableFrom()</code>(是否为父类) 方法、<code>isInstance()</code>(是否为子类) 方法的返回结果为 <code>true</code>，也包括使用 <code>instanceof</code> 关键字做对象所属关系判定结果为 <code>true</code>。</p>
<h2 id="32-类加载器分类">3.2 类加载器分类</h2>
<p><img src="/images/JVM/classLoad/classLoader.png" alt="">
站在 Java 虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另外一种就是其他所有类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</p>
<h3 id="1-bootstrap-classloader"><strong>(1) BootStrap ClassLoader</strong></h3>
<p><code>Bootstrap ClassLoader:</code>即启动类加载器 ，<strong>负责加载 JVM 自身工作所需要的类</strong>。</p>
<p><code>Bootstrap ClassLoader</code> 会将<strong>存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中</strong>。</p>
<p><code>Bootstrap ClassLoade</code>r 是由 <code>C++</code> 实现的，它完全由 <code>JVM</code> 自己控制的，启动类加载器无法被 <code>Java</code> 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 <code>null</code> 代替即可。</p>
<h3 id="2-extclassloader"><strong>(2) ExtClassLoader</strong></h3>
<p><code>ExtClassLoader</code>，即扩展类加载器，这个类加载器是由 <code>ExtClassLoader(sun.misc.Launcher\$ExtClassLoader)</code> 实现的。</p>
<p><code>ExtClassLoader</code> 负责将 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
<h3 id="3-appclassloader"><strong>(3) AppClassLoader</strong></h3>
<p><code>AppClassLoader</code>，即应用程序类加载器，这个类加载器是由 <code>AppClassLoader(sun.misc.Launcher\$AppClassLoader)</code> 实现的。由于这个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值，因此一般称为<em>系统类加载器</em>。</p>
<p><code>AppClassLoader</code> 负责加载用户类路径（即 <code>classpath</code>）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<blockquote>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p>
</blockquote>
<h3 id="4-自定义类加载器"><strong>(4) 自定义类加载器</strong></h3>
<p>自定义类加载器可以做到如下几点功能：</p>
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得 <code>java class</code>，例如数据库中和网络中。</li>
</ul>
<p>假设，我们需要自定义一个名为 <code>FileSystemClassLoader</code> 的类加载器，继承自 <code>java.lang.ClassLoader</code>，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 <code>defineClass()</code> 方法来把这些字节代码转换成 <code>java.lang.Class</code> 类的实例。</p>
<p><code>java.lang.ClassLoader</code> 类的方法 <code>loadClass()</code> 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去覆写它，而是通过覆写 <code>findClass()</code> 方法。</p>
<p><code>ClassLoader</code> 常用的场景：</p>
<ul>
<li>容器 - 典型应用：<code>Servlet</code> 容器（如：Tomcat、Jetty）、udf （Mysql、Hive）等。加载解压 jar 包或 war 包后，加载其 Class 到指定的类加载器中运行（通常需要考虑空间隔离）。</li>
<li>热部署、热插拔 - 应用启动后，动态获得某个类信息，然后加载到 JVM 中工作。很多著名的容器软件、框架（如：Spring 等），都使用 ClassLoader 来实现自身的热部署。</li>
</ul>
<p>【示例】自定义一个类加载器:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileSystemClassLoader</span> <span class="kd">extends</span> <span class="n">ClassLoader</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">rootDir</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">FileSystemClassLoader</span><span class="o">(</span><span class="n">String</span> <span class="n">rootDir</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rootDir</span> <span class="o">=</span> <span class="n">rootDir</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//寻找类名对应的字节流，如果没有则异常，否则将该字节码的字节流转化为 Class 对象
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">findClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">classData</span> <span class="o">=</span> <span class="n">getClassData</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">classData</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">defineClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">classData</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">classData</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">ClassNotFoundException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getClassData</span><span class="o">(</span><span class="n">String</span> <span class="n">className</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">path</span> <span class="o">=</span> <span class="n">classNameToPath</span><span class="o">(</span><span class="n">className</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">InputStream</span> <span class="n">ins</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
            <span class="n">ByteArrayOutPutStream</span> <span class="n">baos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">bufferSize</span> <span class="o">=</span> <span class="n">4096</span><span class="o">;</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">bufferSize</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">bytesNumRead</span><span class="o">;</span>
            <span class="k">while</span><span class="o">((</span><span class="n">bytesNumRead</span> <span class="o">=</span> <span class="n">ins</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">){</span>
                <span class="n">baos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">bytesNumRead</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">baos</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="nf">classNameToPath</span><span class="o">(</span><span class="n">String</span> <span class="n">className</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">rootDir</span> <span class="o">+</span> <span class="n">File</span><span class="o">.</span><span class="na">separatorChar</span> <span class="o">+</span> <span class="n">className</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="n">File</span><span class="o">.</span><span class="na">separatorChar</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;.class&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="33-双亲委派">3.3 双亲委派</h2>
<p>【示例】寻找类加载示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ClassLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">loader</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">loader</span><span class="o">.</span><span class="na">getParent</span><span class="o">());</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">loader</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getParent</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Launcher$AppClassLoader</span><span class="nd">@18b4aac2</span>
<span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Launcher$ExtClassLoader</span><span class="nd">@19e1023e</span>
<span class="kc">null</span>
</code></pre></td></tr></table>
</div>
</div><p>从上面的结果可以看出，并没有获取到 <code>ExtClassLoader</code> 的父 <code>Loader</code>，原因是 <code>Bootstrap Loader</code>（引导类加载器）是用 C++ 语言实现的，找不到一个确定的返回父 <code>Loader</code> 的方式，于是就返回 null。</p>
<p>下图展示的类加载器之间的层次关系，称为类加载器的<strong>双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的 Bootstrap ClassLoader 外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</strong>
<img src="/images/JVM/classLoad/twoParents.png" alt=""></p>
<h3 id="1-工作过程"><strong>(1) 工作过程</strong></h3>
<p><strong>一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载。</strong></p>
<h3 id="2-优势"><strong>(2) 优势</strong></h3>
<p><strong>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系</strong>,从而使得基础类得到统一：</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证 Java 程序安全稳定运行</li>
</ul>
<p>例如： <code>java.lang.Object</code> 存放在 <code>rt.jar</code> 中，如果编写另外一个 <code>java.lang.Object</code> 的类并放到 <code>classpath</code> 中，程序可以编译通过。因为双亲委派模型的存在，所以在 <code>rt.jar</code> 中的 <code>Object</code> 比在 <code>classpath</code> 中的 <code>Object</code> 优先级更高，因为 <code>rt.jar</code> 中的 <code>Object</code> 使用的是启动类加载器，而 <code>classpath</code> 中的 <code>Object</code> 使用的是应用程序类加载器。正因为 <code>rt.jar</code> 中的 <code>Object</code> 优先级更高，因为程序中所有的 <code>Object</code> 都是这个 <code>Object。</code></p>
<h3 id="3-实现"><strong>(3) 实现</strong></h3>
<p>以下是抽象类 <code>java.lang.ClassLoader</code> 的代码片段，其中的 <code>loadClass()</code> 方法运行过程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ClassLoader</span> <span class="o">{</span>
    <span class="c1">// The parent class loader for delegation
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ClassLoader</span> <span class="n">parent</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">getClassLoadingLock</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 首先判断该类型是否已经被加载
</span><span class="c1"></span>            <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">findLoadedClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
</span><span class="c1"></span>                <span class="k">try</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// 如果存在父类加载器，就委派给父类加载器加载
</span><span class="c1"></span>                        <span class="n">c</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="c1">// 如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)
</span><span class="c1"></span>                        <span class="n">c</span> <span class="o">=</span> <span class="n">findBootstrapClassOrNull</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 如果父类加载器加载失败，会抛出 ClassNotFoundException
</span><span class="c1"></span>                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
</span><span class="c1"></span>                    <span class="n">c</span> <span class="o">=</span> <span class="n">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">resolve</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">resolveClass</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">findClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ClassNotFoundException</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>【说明】:
</br></p>
<ul>
<li>先检查类是否已经加载过，如果没有则让父类加载器去加载。</li>
<li>当父类加载器加载失败时抛出 <code>ClassNotFoundException</code>，此时尝试自己去加载。</li>
</ul>
</blockquote>
<h2 id="34-classloader-参数">3.4 ClassLoader 参数</h2>
<p>在生产环境上启动 <code>java</code> 应用时，通常会指定一些 <code>ClassLoader</code> 参数，以加载应用所需要的 <code>lib</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">java -jar xxx.jar -classpath lib/*
</code></pre></td></tr></table>
</div>
</div><p>ClassLoader 相关参数选项：</p>
<table>
<thead>
<tr>
<th><strong>参数选项</strong></th>
<th><strong>ClassLoader 类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Xbootclasspath</code></td>
<td><code>Bootstrap ClassLoader</code></td>
<td>设置 Bootstrap ClassLoader 搜索路径。【不常用】</td>
</tr>
<tr>
<td><code>-Xbootclasspath/a	</code></td>
<td><code>Bootstrap ClassLoader</code></td>
<td>把路径添加到已存在的 Bootstrap ClassLoader 搜索路径后面。【常用】</td>
</tr>
<tr>
<td><code>-Xbootclasspath/p</code></td>
<td><code>Bootstrap ClassLoader</code></td>
<td>把路径添加到已存在的 Bootstrap ClassLoader 搜索路径前面。【不常用】</td>
</tr>
<tr>
<td><code>-Djava.ext.dirs</code></td>
<td><code>ExtClassLoader</code></td>
<td>设置 ExtClassLoader 搜索路径。</td>
</tr>
<tr>
<td><code>-Djava.class.path 或 -cp 或 -classpath</code></td>
<td><code>AppClassLoader</code></td>
<td>设置 AppClassLoader 搜索路径。</td>
</tr>
</tbody>
</table>
<h1 id="四类的加载">四、类的加载</h1>
<h2 id="41-类加载方式">4.1 类加载方式</h2>
<p>类加载方式有三种：</p>
<ul>
<li>命令行启动应用时候由 JVM 初始化加载。</li>
<li>通过 <code>Class.forName()</code> 方法动态加载。</li>
<li>通过 <code>ClassLoader.loadClass()</code> 方法动态加载。</li>
</ul>
<p><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 区别</p>
<ul>
<li><code>Class.forName()</code>将类的<code>.class</code>文件加载到 <code>jvm</code> 中之外，还会对类进行解释，执行类中的 static 块；</li>
<li><code>ClassLoader.loadClass()</code> 只干一件事情，就是将 <code>.class</code> 文件加载到 <code>jvm</code> 中，不会执行 <code>static</code> 中的内容，只有在 <code>newInstance</code> 才会去执行 <code>static</code> 块。</li>
<li><code>Class.forName(name, initialize, loader)</code> 带参函数也可控制是否加载 <code>static</code> 块。并且只有调用了 <code>newInstance()</code> 方法采用调用构造函数，创建类的对象。</li>
</ul>
<h2 id="42-加载类错误">4.2 加载类错误</h2>
<ol>
<li><code>ClassNotFoundException</code>:
表示当前 classpath 下找不到指定类。
常见问题原因：
<ul>
<li>调用 <code>Class</code> 的 <code>forName()</code> 方法，未找到类。</li>
<li>调用 <code>ClassLoader</code> 中的 <code>loadClass()</code> 方法，未找到类。</li>
<li>调用 <code>ClassLoader</code> 中的 <code>findSystemClass()</code> 方法，未找到类。</li>
</ul>
</li>
<li><code>NoClassDefFoundError</code>
常见问题原因：
<ul>
<li>类依赖的 <code>Class</code> 或者 <code>jar</code> 不存在。</li>
<li>类文件存在，但是存在不同的域中。</li>
</ul>
</li>
<li><code>UnsatisfiedLinkError</code>:
常是在 JVM 启动的时候如果一不小心将在 JVM 中的某个 <code>lib</code> 删除了，可能就会报这个错误了。</li>
<li><code>ClassCastException</code>:
异常通常是在程序中强制类型转换失败时出现。</li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">拾光</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2021-12-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/jvm/">JVM</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/2021/12/jvm%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">
            <span class="next-text nav-default">JVM之内存模型</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="yang_95@126.com" class="iconfont icon-email" title="email"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Huan</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>



<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
