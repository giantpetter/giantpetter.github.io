<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>线程的属性、状态、生命周期详解 | 杨欢的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="一、线程简介 线程 （英语：thread）是操作系统能够进行运算调度的最小单位。 大部分情况下，它被包含在进程之中，是进程中的实际运作单位。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。
二、线程属性  线程是处理机调度的单位 多cpu计算机中，各个线程可以占用不同的cpu 每个线程都有一个线程ID、线程控制块（TCB） 线程类似进程也有就绪、堵塞、运行三种状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间资源，同一进程的线程间通信甚至无需系统干预 同一进程的线程切换，不会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销很大  三、多线程模型  首先介绍线程的实现方式   用户级线程(User-Level Thread,ULT)：由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程的切换)，无需操作系统干预。   内核级线程(Kernel-Level Thread,KLT):线程管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责。 可以说内核级线程就是&quot;从操作系统内核视角可以看到的线程&quot;。   只有内核级线程才是处理机分配的单位
 多线程模型  由几个用户级线程映射到记个内核级线程的问题引出了&quot;多线程模型问题&quot;
模型包括三个：
 多对一模型：多个用户级线程映射到一个内核级线程。开销小，效率高，但是并发度不高，不支持多核处理器并行。 一对一模型：一个用户级线程映射到一个内核级线程。并发程度高，但是开销大，效率低。 多对多模型：如下图，n个用户线程映射到m个内核级线程(n&gt;=m)。每个用户进程对应m个内核级线程。集合了以上两个模型的优点。   四、线程生命周期 关于Java中线程的生命周期，首先看一下下面这张较为经典的图： 上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：
Java线程具有五中基本状态
 新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread(); 就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行； 运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：  等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态； 同步阻塞 &ndash; 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态； 其他阻塞 &ndash; 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。   死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。  Java多线程的就绪、运行和死亡状态(注意点)">
    <meta name="generator" content="Hugo 0.83.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
    <meta property="og:title" content="线程的属性、状态、生命周期详解" />
<meta property="og:description" content="一、线程简介 线程 （英语：thread）是操作系统能够进行运算调度的最小单位。 大部分情况下，它被包含在进程之中，是进程中的实际运作单位。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。
二、线程属性  线程是处理机调度的单位 多cpu计算机中，各个线程可以占用不同的cpu 每个线程都有一个线程ID、线程控制块（TCB） 线程类似进程也有就绪、堵塞、运行三种状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间资源，同一进程的线程间通信甚至无需系统干预 同一进程的线程切换，不会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销很大  三、多线程模型  首先介绍线程的实现方式   用户级线程(User-Level Thread,ULT)：由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程的切换)，无需操作系统干预。   内核级线程(Kernel-Level Thread,KLT):线程管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责。 可以说内核级线程就是&quot;从操作系统内核视角可以看到的线程&quot;。   只有内核级线程才是处理机分配的单位
 多线程模型  由几个用户级线程映射到记个内核级线程的问题引出了&quot;多线程模型问题&quot;
模型包括三个：
 多对一模型：多个用户级线程映射到一个内核级线程。开销小，效率高，但是并发度不高，不支持多核处理器并行。 一对一模型：一个用户级线程映射到一个内核级线程。并发程度高，但是开销大，效率低。 多对多模型：如下图，n个用户线程映射到m个内核级线程(n&gt;=m)。每个用户进程对应m个内核级线程。集合了以上两个模型的优点。   四、线程生命周期 关于Java中线程的生命周期，首先看一下下面这张较为经典的图： 上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：
Java线程具有五中基本状态
 新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread(); 就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行； 运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：  等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态； 同步阻塞 &ndash; 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态； 其他阻塞 &ndash; 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。   死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。  Java多线程的就绪、运行和死亡状态(注意点)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://giantpetter.github.io/posts/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E7%8A%B6%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-21T16:02:46&#43;08:00" />
<meta property="article:modified_time" content="2021-05-21T16:02:46&#43;08:00" />

<meta itemprop="name" content="线程的属性、状态、生命周期详解">
<meta itemprop="description" content="一、线程简介 线程 （英语：thread）是操作系统能够进行运算调度的最小单位。 大部分情况下，它被包含在进程之中，是进程中的实际运作单位。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。
二、线程属性  线程是处理机调度的单位 多cpu计算机中，各个线程可以占用不同的cpu 每个线程都有一个线程ID、线程控制块（TCB） 线程类似进程也有就绪、堵塞、运行三种状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间资源，同一进程的线程间通信甚至无需系统干预 同一进程的线程切换，不会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销很大  三、多线程模型  首先介绍线程的实现方式   用户级线程(User-Level Thread,ULT)：由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程的切换)，无需操作系统干预。   内核级线程(Kernel-Level Thread,KLT):线程管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责。 可以说内核级线程就是&quot;从操作系统内核视角可以看到的线程&quot;。   只有内核级线程才是处理机分配的单位
 多线程模型  由几个用户级线程映射到记个内核级线程的问题引出了&quot;多线程模型问题&quot;
模型包括三个：
 多对一模型：多个用户级线程映射到一个内核级线程。开销小，效率高，但是并发度不高，不支持多核处理器并行。 一对一模型：一个用户级线程映射到一个内核级线程。并发程度高，但是开销大，效率低。 多对多模型：如下图，n个用户线程映射到m个内核级线程(n&gt;=m)。每个用户进程对应m个内核级线程。集合了以上两个模型的优点。   四、线程生命周期 关于Java中线程的生命周期，首先看一下下面这张较为经典的图： 上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：
Java线程具有五中基本状态
 新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread(); 就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行； 运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：  等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态； 同步阻塞 &ndash; 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态； 其他阻塞 &ndash; 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。   死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。  Java多线程的就绪、运行和死亡状态(注意点)"><meta itemprop="datePublished" content="2021-05-21T16:02:46&#43;08:00" />
<meta itemprop="dateModified" content="2021-05-21T16:02:46&#43;08:00" />
<meta itemprop="wordCount" content="63">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="线程的属性、状态、生命周期详解"/>
<meta name="twitter:description" content="一、线程简介 线程 （英语：thread）是操作系统能够进行运算调度的最小单位。 大部分情况下，它被包含在进程之中，是进程中的实际运作单位。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。
二、线程属性  线程是处理机调度的单位 多cpu计算机中，各个线程可以占用不同的cpu 每个线程都有一个线程ID、线程控制块（TCB） 线程类似进程也有就绪、堵塞、运行三种状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间资源，同一进程的线程间通信甚至无需系统干预 同一进程的线程切换，不会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销很大  三、多线程模型  首先介绍线程的实现方式   用户级线程(User-Level Thread,ULT)：由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程的切换)，无需操作系统干预。   内核级线程(Kernel-Level Thread,KLT):线程管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责。 可以说内核级线程就是&quot;从操作系统内核视角可以看到的线程&quot;。   只有内核级线程才是处理机分配的单位
 多线程模型  由几个用户级线程映射到记个内核级线程的问题引出了&quot;多线程模型问题&quot;
模型包括三个：
 多对一模型：多个用户级线程映射到一个内核级线程。开销小，效率高，但是并发度不高，不支持多核处理器并行。 一对一模型：一个用户级线程映射到一个内核级线程。并发程度高，但是开销大，效率低。 多对多模型：如下图，n个用户线程映射到m个内核级线程(n&gt;=m)。每个用户进程对应m个内核级线程。集合了以上两个模型的优点。   四、线程生命周期 关于Java中线程的生命周期，首先看一下下面这张较为经典的图： 上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：
Java线程具有五中基本状态
 新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread(); 就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行； 运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：  等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态； 同步阻塞 &ndash; 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态； 其他阻塞 &ndash; 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。   死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。  Java多线程的就绪、运行和死亡状态(注意点)"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        杨欢的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://giantpetter.github.io/posts/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E7%8A%B6%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://giantpetter.github.io/posts/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E7%8A%B6%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/&amp;text=%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%b1%9e%e6%80%a7%e3%80%81%e7%8a%b6%e6%80%81%e3%80%81%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://giantpetter.github.io/posts/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E7%8A%B6%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/&amp;title=%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%b1%9e%e6%80%a7%e3%80%81%e7%8a%b6%e6%80%81%e3%80%81%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%af%a6%e8%a7%a3" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">线程的属性、状态、生命周期详解</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-05-21T16:02:46+08:00">May 21, 2021</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id="一线程简介">一、线程简介</h1>
<p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B">线程</a>
（英语：thread）是操作系统能够进行运算调度的最小单位。
大部分情况下，它被包含在进程之中，是进程中的实际运作单位。
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
<h1 id="二线程属性">二、线程属性</h1>
<ul>
<li>线程是处理机调度的单位</li>
<li>多cpu计算机中，各个线程可以占用不同的cpu</li>
<li>每个线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程类似进程也有就绪、堵塞、运行三种状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间资源，同一进程的线程间通信甚至无需系统干预</li>
<li>同一进程的线程切换，不会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销很大</li>
</ul>
<h1 id="三多线程模型">三、多线程模型</h1>
<ol>
<li>首先介绍线程的实现方式</li>
</ol>
<ul>
<li>用户级线程(User-Level Thread,ULT)：由应用程序通过线程库实现。所有的线程管理工作都由<strong>应用程序负责</strong>(包括线程的切换)，无需操作系统干预。</li>
</ul>
<p><img src="/images/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<ul>
<li>内核级线程(Kernel-Level Thread,KLT):线程管理工作由<em>操作系统内核</em>完成。线程调度、切换等工作都由内核负责。
可以说<em>内核级线程就是&quot;从操作系统内核视角可以看到的线程&quot;</em>。</li>
</ul>
<blockquote>
<p>只有内核级线程才是处理机分配的单位</p>
</blockquote>
<p><img src="/images/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<ol start="2">
<li>多线程模型</li>
</ol>
<p>由几个用户级线程映射到记个内核级线程的问题引出了&quot;多线程模型问题&quot;</p>
<p>模型包括三个：</p>
<ul>
<li>多对一模型：多个用户级线程映射到一个内核级线程。开销小，效率高，但是并发度不高，不支持多核处理器并行。</li>
<li>一对一模型：一个用户级线程映射到一个内核级线程。并发程度高，但是开销大，效率低。</li>
<li>多对多模型：如下图，n个用户线程映射到m个内核级线程(n&gt;=m)。每个用户进程对应m个内核级线程。集合了以上两个模型的优点。
<img src="/images/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B.png" alt=""></li>
</ul>
<h1 id="四线程生命周期">四、线程生命周期</h1>
<p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：
<img src="/images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p>
<p>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p>
<p><strong>Java线程具有五中基本状态</strong></p>
<ul>
<li>新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</li>
<li>就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li>
<li>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li>
<li>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：
<ol>
<li>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</li>
<li>同步阻塞 &ndash; 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li>
<li>其他阻塞 &ndash; 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ol>
</li>
<li>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ul>
<p><strong>Java多线程的就绪、运行和死亡状态(<em>注意点</em>)</strong></p>
<ul>
<li>就绪状态转换为运行状态：当此线程得到处理器资源；</li>
<li>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</li>
<li>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</li>
</ul>
<blockquote>
<p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p>
</blockquote>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://giantpetter.github.io" >
    &copy;  杨欢的博客 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
